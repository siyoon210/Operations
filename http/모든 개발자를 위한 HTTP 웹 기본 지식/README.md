# 모든 개발자를 위한 HTTP 웹 기본 지식
[모든 개발자를 위한 HTTP 웹 기본 지식 (인프런 - 김영한)](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)
## 섹션1. 인터넷 네트워크 (21.1.6)
### [인터넷 통신]

### [IP(인터넷 프로토콜)]
- 패킷이라는 통신단위로 데이터를 전달한다.
- IP 프토토콜을 이용하여서 떨어진 두 컴퓨터간의 패킷을 주고 받을 수 있다.
- IP 패킷에는 출발지 IP주소와 도착지 IP 주소를 표기하여 인터넷망에 여러 노드들을 거쳐 도착지까지 전송한다.

#### IP 프로토콜의 단점
1. 비연결성
- 패킷이 도착지까지 전달되지 않아도 확인할 수 없다.

2. 비신뢰성
- 패킷의 크기가 큰 경우 여러가지의 작은 패킷으로 나누어 전송하게 되는데,
	- 노드들을 거치다가 일부 패킷이 소실되어도 알 수 가 없다.
	- 패킷의 순서를 알 수 가 없다.

3. 여러 애플리케이션 사용시에 문제점
- 같은 IP를 사용하는 하나의 컴퓨터라도 여러 인터넷 어플리케이션을 실행하고 있다면, 해당 패킷이 어떤 애플리케이션으로 전송되었는지 확인 할 수 없다. 

### [TCP, UDP]
#### TCP
- IP 프로토콜의 단점을 보완한 인터넷 프로토콜로, IP 프로토콜를 사용하는 상위 계층 프로토콜이다.

1. 비연결성 해결
	- TCP통신은 도착지와 통신을 하기 이전에 도착지의 정보각 정확한지 3 way handshake를 통해서 확인하고 비연결성 문제를 해결한다.

2. 비신뢰성 해결
	- 패킷을 여러개로 나누어 보내더라도 패킷들의 순서와 패킷의 크기 검증을 진행하여 비신뢰성을 해결한다.
	- 데이터 전송후에 데이터를 잘 받았다는 패킷을 역으로 전송하여 데이터 전달을 보증한다.

3. 여러 애플리케이션 사용시의 문제점 해결
	- 'PORT' 라는 컴퓨터 내부에서 사용하게 되는 애플리케이션과의 구분자를 통해서 문제점을 해결한다.
	
#### UDP
- UDP는 IP프로토콜의 문제점중 3번문제를 PORT를 통해서만 해결한다. 신뢰성이 낮은대신에 빠르다.

### [PORT]
- TCP/IP를 사용하는 애플리케이션들을 구분하기 위한 번호로 0~65535번까지 사용할 수 있다.
- 1023번까지는 잘 알려진 애플리케이션의 프로토콜로 사용하지 않는다.
	- http:80, https:443, ftp:20,21 telnet:23 ...

### [DNS (Domain Name System)]
- IP주소는 기억하기 어렵고, 가변적이기 떄문에 IP 주소만으로 통신하게 되면 기억해두기 어렵다.
- 이를 해결하기 위해서 DNS를 사용한다. 
- 도메인 이름을 네트워크 주소로 바꾸거나 그 반대의 변환을 수행할 수 있도록 할 수 있다.

## 섹션2. URI와 웹 브라우저 요청 흐름 (21.1.7)
### [URI]
- URI(Uiform Resource R Identifier
	- Uniform (리소스 식별하는 통일된 방식), Resource(자원), Identifier(다른 항목과 구분하는데 필요한 정보)
	- 요청한 자원을 식별학기 위함.
	- URL(Uiform Resource Location)와 URN(Uiform Resource Name)는 URI의 부분 집합이다.
	- Location(위치)는 변경될 수 있으나 Name(이름)은 변경되지 않난다.
- URL = scheme://[userinfo@]host[:port][/path][?query][#fragment]

### [웹 브라우저 요청 흐름]
- 브라우저(애플리케이션)에서 (Http)메세지를 만들고, 이 메시지를 TCP/IP 규격에 맞게 OS에서 IP와 PORT정보를 더하여 감싸 패킷을 만든다.
	- (출발지 IP,PORT / 도착지 IP,PORT (Http 메시지))
- 네트워크 인터페이스 (랜 드라이버, 랜 장비)가 이 패킷에 원하는 정보를 추가하고 인터넷 망을 통해 서버에 전달되도록 한다.
- 서버에서 응답받은 패킷을 벗겨서 Http메서드를 분석하여 어떤 정보를 요청했는지 파악하고 응답한다.

## 섹션3. HTTP 기본 (21.1.8)
### [모든 것이 HTTP]
- 요즘 대부분의 웹 프로토콜은 http를 많이 사용한다. html 전송 뿐만 아니라 이미지, 영상, json, xml 등등 byte로 나타낼 수 있는 모든 것들을 전송한다.
- HTTP 1.1, HTTP2는 TCP를 사용하지만 HTTP3는 UDP를 사용한다.
- HTTP는 클라이언트 서버 구조, 무상태, 비연결성, HTTP 메시지, 단순하고 확장가능하다는 특징이 있다.

### [클라이언트 서버 구조]
- Request Response 구조
- 클라이언트가 요청을 보내고 응답을 대기하면 서버가 요청에 대한 결과를 만들어서 응답한다.

### [Stateful, Stateless]
- Stateful
	- 서버가 클라이언트의 상태를 저장한다.
	- 장점: 로그인과 같이 클라이언트 정보를 저장해야 하는 경우 구현할 수 있다.
	- 단점: 서버의 확장이 어렵다.
- Stateless
	- 서버가 클라이언트의 상태를 저장하지 않는다.
	- 장점: 서버의 확장에 유리하고, 클라이언트가 한 서버에 종속되지 않는다.
	- 단점: 요청메시지가 커진다. 모든 기능이 Stateless로 구현될 수 없다.
- 가능한 Stateless로 설계하는 것이 확장성이 좋다.

### [비 연결성 Connectionless]
- 서버가 하나의 클라이언트와 통신한 이후에 연결을 끊어서 자원을 효율적으로 사용한다.
- 매 연결시마다 연결을 새로 맺으면 3 way handshake와 같은 작업을 매번 해야 하므로, 약간의 텀을 두어 연결을 끊기도 한다.

### [HTTP 메시지]
- HTTP 메시지는 시작라인, 헤더, 빈줄, 바디로 나누어진다.
- 요청시에 시작라인에는 HTTP 메서드와 path정보를 넣고, 응답시에는 HTTP 프로토콜 버전과 상태코드를 보내준다.
- 헤더에는 HTTP 전송에 필요한 부가정보를 넣는다. (메세지타입, 매세지크기, 압축, 인증, 클라이언트 정보...) 키-밸류로 이뤄져 있으며 표준으로 사용되는 헤더도 있지만 클라이언트와 서버가 약속된 헤더가 있다면 커스텀한 키도 사용하다.
- 헤더와 바디사이에는 반드시 빈줄이 있어야 한다.(프로토콜)
- 바디는 정보의 핵심 컨텐츠를 담는다.

## 섹션 4. HTTP 메서드 (21.1.9)
### [HTTP API를 만들어보자]
- HTTP URI는 리소스만 명시하는 것이 원칙이다. 행위는 Http 메서드로 구분하자.

### [HTTP 메서드 - GET, POST]
- GET은 리소스를 조회할때 사용한다.
	- 최근 스펙에서는 요청바디를 허용하지만, 아직까지 많은 서버가 지원하지 않으므로 바디는 사용하지 않도록 한다.
- POST는 리소스를 등록하거나 '처리'할때도 사용된다.
	- 주로 리소스를 새로 등록하는 경우에 사용된다.
	- 다른 메서드에서 처리하지 못하는 경우도 사용된다. (예를들어 HTTP 메서드만으로 행위를 나타낼 수 없는 경우, GET처럼 요청 바디가 없는 경우)
		- 리소스를 처리하기 위해서 URI에 행위를 명시하는 것이 허용된다. ex) POST /resource/{id}/start-processing

### [HTTP 메서드 - PUT, PATCH, DELETE]
- PUT은 리소스를 대체하는 경우다. 리소스 식별자(id)가 명시되기 때문에 POST와 다르다.
	- 덮어 씌우기 떄문에 리소스의 온전한 정보가 없다면 그 정보가 사라진다. (예를들어 이름이라는 필드가 저장되어 있는데 PUT으로 이름을 넘겨주지 않으면 null이 들어감)
	- 만약 리소스 식별자로 존재한다면 덮어씌운다!! 없으면 새로 만든다.
- PATCH는 PUT과 유사하지만 일부부만 변경할때 사용된다.
- DELETE 리소스 삭제

### [HTTP 메서드의 속성]
1. 안전
	- GET, HEAD 같은 경우는 조회만 수행하기 때문에 리소스가 '안전'하다. POST, PUT, PATCH는 리소스 정보가 변경 되기 떄문에 안전하지 않다.
2. 멱등
	- GET, PATCH, PUT은 같은 요청에 같은 응답과 결과가 예상된다. POST는 그렇지 않다. 
	- 멱등은 리소스 한번 조회에 대해서 고려하며 외부 요인도 고려하지 않는다.
3. 캐시
	- GET, HEAD, POST, PATCH에 경우 캐시가 가능하지만 실제로는 GET, HEAD만 가능하다.
	
## 섹션 5. HTTP 메서드 활용 (21.1.10)
### [클라이언트에서 서버로 데이터 전송]
- 정적데이터 요청시(ex 이미지) GET 요청
- 동적데이터 요청시(ex 필터링, 검색, 페이징) GET요청에 쿼리스트링으로 동적데이터 전송
- HTML form을 사용한 전송
	- form의 method를 POST를 사용하는 경우 Content-type: application/x-www-form-urlencoded로 설정되고 body에 form데이터가 key,value로 설정된다.
	- form의 method를 GET을 사용하는 경우 form 데이터를 쿼리스트링으로 만들어 준다. (form을 적절히 사용하면 쿼리스트링을 만들기 훨씬 쉽겠군!)
	-  파일을 전송해야 하는 경우 enctype="multipart/form-data"를 명시하며 boundaray=로 데이터들을 구분하여 전송된다.
	```
	POST /save HTTP/1.1
	HOST: localhost:8080
	Content-Type: multipart/form-data; boundary=---XXX
	
	---XXX
	Content-Disposition: form-data; name="username"
	
	kim

	---XXX
	Content-Disposition: form-data; name="age"
	
	20
	---XXX
	Content-Disposition: form-data; name="file1"l filename="intro.png"
	Content-Type: image/png
	
	.....
	```
- HTTP  API를 통한 전송

### [HTTP API 설계 예시]
#### 문서(Document)
- 리소스 단일개념
- ex) /members/100, /files/star.jpg

#### 컬렉션(Collection)
- 서버가 리소스 디렉토리를 관리하는 방식
	- 스토어 보다 일반적으로  쓰인다.
	- id(식별자)를 서버에서 생성 및  관리
	- 클라이언트는 리소스 id(식별자)를 모르기 때문에 POST를 통한 리소스 생성  (ex /members)
- ex) /members

#### 스토어(Store)
- 클라이언트가 리소스 디렉토리를 관리하는 방식
	- id(식별자)를 클라이언트가 관리
	- 클라이언트가 id를 사용하여 PUT으로 리소스를 생성한다. (ex /files/star.jpg) 
	- 해당 식별자가 없으면 생성, 있으면 덮어쓰기
- ex) /files

#### 컨트롤러, 컨트롤 URI
- 문서, 컬렉션, 스토어 (혹은 HTTP 메서드)만으로 해결하기 어려운 경우 URI에 동사를 사용한다.
- ex) /memebers/100/delete
- (동사를 사용하는 것에 찝찝함이 있었는데 한계를 모두 인정하고 컨트롤URI와 같은 개념이 있구나..! :) )
