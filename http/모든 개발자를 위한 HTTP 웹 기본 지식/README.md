# 모든 개발자를 위한 HTTP 웹 기본 지식
[모든 개발자를 위한 HTTP 웹 기본 지식 (인프런 - 김영한)](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC/dashboard)
## 섹션1. 인터넷 네트워크 (21.1.6)
### [인터넷 통신]

### [IP(인터넷 프로토콜)]
- 패킷이라는 통신단위로 데이터를 전달한다.
- IP 프토토콜을 이용하여서 떨어진 두 컴퓨터간의 패킷을 주고 받을 수 있다.
- IP 패킷에는 출발지 IP주소와 도착지 IP 주소를 표기하여 인터넷망에 여러 노드들을 거쳐 도착지까지 전송한다.

#### IP 프로토콜의 단점
1. 비연결성
- 패킷이 도착지까지 전달되지 않아도 확인할 수 없다.

2. 비신뢰성
- 패킷의 크기가 큰 경우 여러가지의 작은 패킷으로 나누어 전송하게 되는데,
	- 노드들을 거치다가 일부 패킷이 소실되어도 알 수 가 없다.
	- 패킷의 순서를 알 수 가 없다.

3. 여러 애플리케이션 사용시에 문제점
- 같은 IP를 사용하는 하나의 컴퓨터라도 여러 인터넷 어플리케이션을 실행하고 있다면, 해당 패킷이 어떤 애플리케이션으로 전송되었는지 확인 할 수 없다. 

### [TCP, UDP]
#### TCP
- IP 프로토콜의 단점을 보완한 인터넷 프로토콜로, IP 프로토콜를 사용하는 상위 계층 프로토콜이다.

1. 비연결성 해결
	- TCP통신은 도착지와 통신을 하기 이전에 도착지의 정보각 정확한지 3 way handshake를 통해서 확인하고 비연결성 문제를 해결한다.

2. 비신뢰성 해결
	- 패킷을 여러개로 나누어 보내더라도 패킷들의 순서와 패킷의 크기 검증을 진행하여 비신뢰성을 해결한다.
	- 데이터 전송후에 데이터를 잘 받았다는 패킷을 역으로 전송하여 데이터 전달을 보증한다.

3. 여러 애플리케이션 사용시의 문제점 해결
	- 'PORT' 라는 컴퓨터 내부에서 사용하게 되는 애플리케이션과의 구분자를 통해서 문제점을 해결한다.
	
#### UDP
- UDP는 IP프로토콜의 문제점중 3번문제를 PORT를 통해서만 해결한다. 신뢰성이 낮은대신에 빠르다.

### [PORT]
- TCP/IP를 사용하는 애플리케이션들을 구분하기 위한 번호로 0~65535번까지 사용할 수 있다.
- 1023번까지는 잘 알려진 애플리케이션의 프로토콜로 사용하지 않는다.
	- http:80, https:443, ftp:20,21 telnet:23 ...

### [DNS (Domain Name System)]
- IP주소는 기억하기 어렵고, 가변적이기 떄문에 IP 주소만으로 통신하게 되면 기억해두기 어렵다.
- 이를 해결하기 위해서 DNS를 사용한다. 
- 도메인 이름을 네트워크 주소로 바꾸거나 그 반대의 변환을 수행할 수 있도록 할 수 있다.

## 섹션2. URI와 웹 브라우저 요청 흐름 (21.1.7)
### [URI]
- URI(Uiform Resource R Identifier
	- Uniform (리소스 식별하는 통일된 방식), Resource(자원), Identifier(다른 항목과 구분하는데 필요한 정보)
	- 요청한 자원을 식별학기 위함.
	- URL(Uiform Resource Location)와 URN(Uiform Resource Name)는 URI의 부분 집합이다.
	- Location(위치)는 변경될 수 있으나 Name(이름)은 변경되지 않난다.
- URL = scheme://[userinfo@]host[:port][/path][?query][#fragment]

### [웹 브라우저 요청 흐름]
- 브라우저(애플리케이션)에서 (Http)메세지를 만들고, 이 메시지를 TCP/IP 규격에 맞게 OS에서 IP와 PORT정보를 더하여 감싸 패킷을 만든다.
	- (출발지 IP,PORT / 도착지 IP,PORT (Http 메시지))
- 네트워크 인터페이스 (랜 드라이버, 랜 장비)가 이 패킷에 원하는 정보를 추가하고 인터넷 망을 통해 서버에 전달되도록 한다.
- 서버에서 응답받은 패킷을 벗겨서 Http메서드를 분석하여 어떤 정보를 요청했는지 파악하고 응답한다.

## 섹션3. HTTP 기본 (21.1.8)
### [모든 것이 HTTP]
- 요즘 대부분의 웹 프로토콜은 http를 많이 사용한다. html 전송 뿐만 아니라 이미지, 영상, json, xml 등등 byte로 나타낼 수 있는 모든 것들을 전송한다.
- HTTP 1.1, HTTP2는 TCP를 사용하지만 HTTP3는 UDP를 사용한다.
- HTTP는 클라이언트 서버 구조, 무상태, 비연결성, HTTP 메시지, 단순하고 확장가능하다는 특징이 있다.

### [클라이언트 서버 구조]
- Request Response 구조
- 클라이언트가 요청을 보내고 응답을 대기하면 서버가 요청에 대한 결과를 만들어서 응답한다.

### [Stateful, Stateless]
- Stateful
	- 서버가 클라이언트의 상태를 저장한다.
	- 장점: 로그인과 같이 클라이언트 정보를 저장해야 하는 경우 구현할 수 있다.
	- 단점: 서버의 확장이 어렵다.
- Stateless
	- 서버가 클라이언트의 상태를 저장하지 않는다.
	- 장점: 서버의 확장에 유리하고, 클라이언트가 한 서버에 종속되지 않는다.
	- 단점: 요청메시지가 커진다. 모든 기능이 Stateless로 구현될 수 없다.
- 가능한 Stateless로 설계하는 것이 확장성이 좋다.

### [비 연결성 Connectionless]
- 서버가 하나의 클라이언트와 통신한 이후에 연결을 끊어서 자원을 효율적으로 사용한다.
- 매 연결시마다 연결을 새로 맺으면 3 way handshake와 같은 작업을 매번 해야 하므로, 약간의 텀을 두어 연결을 끊기도 한다.

### [HTTP 메시지]
- HTTP 메시지는 시작라인, 헤더, 빈줄, 바디로 나누어진다.
- 요청시에 시작라인에는 HTTP 메서드와 path정보를 넣고, 응답시에는 HTTP 프로토콜 버전과 상태코드를 보내준다.
- 헤더에는 HTTP 전송에 필요한 부가정보를 넣는다. (메세지타입, 매세지크기, 압축, 인증, 클라이언트 정보...) 키-밸류로 이뤄져 있으며 표준으로 사용되는 헤더도 있지만 클라이언트와 서버가 약속된 헤더가 있다면 커스텀한 키도 사용하다.
- 헤더와 바디사이에는 반드시 빈줄이 있어야 한다.(프로토콜)
- 바디는 정보의 핵심 컨텐츠를 담는다.

## 섹션 4. HTTP 메서드 (21.1.9)
### [HTTP API를 만들어보자]
- HTTP URI는 리소스만 명시하는 것이 원칙이다. 행위는 Http 메서드로 구분하자.

### [HTTP 메서드 - GET, POST]
- GET은 리소스를 조회할때 사용한다.
	- 최근 스펙에서는 요청바디를 허용하지만, 아직까지 많은 서버가 지원하지 않으므로 바디는 사용하지 않도록 한다.
- POST는 리소스를 등록하거나 '처리'할때도 사용된다.
	- 주로 리소스를 새로 등록하는 경우에 사용된다.
	- 다른 메서드에서 처리하지 못하는 경우도 사용된다. (예를들어 HTTP 메서드만으로 행위를 나타낼 수 없는 경우, GET처럼 요청 바디가 없는 경우)
		- 리소스를 처리하기 위해서 URI에 행위를 명시하는 것이 허용된다. ex) POST /resource/{id}/start-processing

### [HTTP 메서드 - PUT, PATCH, DELETE]
- PUT은 리소스를 대체하는 경우다. 리소스 식별자(id)가 명시되기 때문에 POST와 다르다.
	- 덮어 씌우기 떄문에 리소스의 온전한 정보가 없다면 그 정보가 사라진다. (예를들어 이름이라는 필드가 저장되어 있는데 PUT으로 이름을 넘겨주지 않으면 null이 들어감)
	- 만약 리소스 식별자로 존재한다면 덮어씌운다!! 없으면 새로 만든다.
- PATCH는 PUT과 유사하지만 일부부만 변경할때 사용된다.
- DELETE 리소스 삭제

### [HTTP 메서드의 속성]
1. 안전
	- GET, HEAD 같은 경우는 조회만 수행하기 때문에 리소스가 '안전'하다. POST, PUT, PATCH는 리소스 정보가 변경 되기 떄문에 안전하지 않다.
2. 멱등
	- GET, PATCH, PUT은 같은 요청에 같은 응답과 결과가 예상된다. POST는 그렇지 않다. 
	- 멱등은 리소스 한번 조회에 대해서 고려하며 외부 요인도 고려하지 않는다.
3. 캐시
	- GET, HEAD, POST, PATCH에 경우 캐시가 가능하지만 실제로는 GET, HEAD만 가능하다.
	
## 섹션 5. HTTP 메서드 활용 (21.1.10)
### [클라이언트에서 서버로 데이터 전송]
- 정적데이터 요청시(ex 이미지) GET 요청
- 동적데이터 요청시(ex 필터링, 검색, 페이징) GET요청에 쿼리스트링으로 동적데이터 전송
- HTML form을 사용한 전송
	- form의 method를 POST를 사용하는 경우 Content-type: application/x-www-form-urlencoded로 설정되고 body에 form데이터가 key,value로 설정된다.
	- form의 method를 GET을 사용하는 경우 form 데이터를 쿼리스트링으로 만들어 준다. (form을 적절히 사용하면 쿼리스트링을 만들기 훨씬 쉽겠군!)
	-  파일을 전송해야 하는 경우 enctype="multipart/form-data"를 명시하며 boundaray=로 데이터들을 구분하여 전송된다.
	```
	POST /save HTTP/1.1
	HOST: localhost:8080
	Content-Type: multipart/form-data; boundary=---XXX
	
	---XXX
	Content-Disposition: form-data; name="username"
	
	kim

	---XXX
	Content-Disposition: form-data; name="age"
	
	20
	---XXX
	Content-Disposition: form-data; name="file1"l filename="intro.png"
	Content-Type: image/png
	
	.....
	```
- HTTP  API를 통한 전송

### [HTTP API 설계 예시]
#### 문서(Document)
- 리소스 단일개념
- ex) /members/100, /files/star.jpg

#### 컬렉션(Collection)
- 서버가 리소스 디렉토리를 관리하는 방식
	- 스토어 보다 일반적으로  쓰인다.
	- id(식별자)를 서버에서 생성 및  관리
	- 클라이언트는 리소스 id(식별자)를 모르기 때문에 POST를 통한 리소스 생성  (ex /members)
- ex) /members

#### 스토어(Store)
- 클라이언트가 리소스 디렉토리를 관리하는 방식
	- id(식별자)를 클라이언트가 관리
	- 클라이언트가 id를 사용하여 PUT으로 리소스를 생성한다. (ex /files/star.jpg) 
	- 해당 식별자가 없으면 생성, 있으면 덮어쓰기
- ex) /files

#### 컨트롤러, 컨트롤 URI
- 문서, 컬렉션, 스토어 (혹은 HTTP 메서드)만으로 해결하기 어려운 경우 URI에 동사를 사용한다.
- ex) /memebers/100/delete
- (동사를 사용하는 것에 찝찝함이 있었는데 한계를 모두 인정하고 컨트롤URI와 같은 개념이 있구나..! :) )

- http://restfulapi.net/resource-naming

## 섹션 6. HTTP 상태코드 소개 (21.1.12)
#### 1xx (informational) 요청이 수신되어 처리중
- 사용안함

#### 2xx (successful)  요청 정상 처리
- 200 : 요청 성공
- 201 : 요청으로 인하여 새로운 리소스가 생성됨 (응답헤더 Location에 식별자를 내려준다)
- 202 : 요청이 정상접수 되었으나 처리가 완료되지 않음 (ex 배치처리)
- 204 : 응답 페이러드 본문에 보낼 데이터가 없음

#### 3xx (redorection) 요청을 완료하려면 추가 행동이 필요
- 3xx번대 응답 결과에 Location 헤더가 있으면 브라우저는 자동으로 Location 으로 재요청한다.
- 영구 리다이렉션 : 특정 리소스의 URI가 영구적으로 이동
	- 301 리다이렉트시 요청 메서드가 GET으로 변하고 본문이 제거 될 수 있음 (아닐수도 있다는 말..)
	- 308 리다이렉트시 요청 메서드와 본문 유지
- 일시 리다이렉션 : 일시적인 변경 (ex 주문 후 주문 완료 페이지로; PRG POST REDIRECT GET)
	- 302 리다이렉트시 요청 메서드가 GET으로 변하고 본문이 제거 될 수 있음 (아닐수도 있다는 말..)
	- 307 리다이렉트시 요청메서드와 본문이 유지
	- 303 302와 기능은 같지만 요청 메서드가 반드시 GET으로 변경된다.
- 특수 리다이렉션 : 캐시를 사용하라고 클라이언트(브라우저)에게 알림
	- 304 캐시를 사용하라고 클라이언트(브라우저)에게 알림

#### 4xx (client error) 클라이언트 요청 오류
- 오류의 원인이 클라이언트에게 있다. 그러므로 같은 페이로드라면 계속 요청해도 계속 실패한다.
	- 400 요청 구문이나 메시지가 잘못됨, 요청 스펙에 맞지 않음
	- 401 인증 되지 않음 (로그인) (메시지가 Unauthorized(인가)이지만 실제로는 Authentication(인증) 문제임)
	- 403 로그인 되었지만 접근 권한이 없는 경우 (일반유저가 어드민용 리소스에 접근하는 경우)
	- 404 요청 리소스가 없음

#### 5xx (server error) 서버 오류 (클라이언트는 정상적인 요청)
- 서버 문제로 오류, 5xx으로 실패하더라도 잠시후에 복구가 되면 요청이 될 수 도 있는 경우.
	- 500 서버 내부오류
	- 503 일시적 과부하
- (김영한님은 정말로 서버오류인 경우에 500대를 사용하라고 한다. 만약 성인용 페이지에 15세가 들어왔다면 이건 클라이언트 잘못이 아님)

## 섹션 7. HTTP 헤더1 (21.1.14)
### [HTTP 헤더 개요]
- HTTP 전송에 필요한 부가정보를 나타낸다, (메시지의 크기, 압축방식, 인증, 서버 정보..)
- 정의된 표준헤더 외에 임의의 헤더도 추가 가능하다.

### [표현]
- HTTP표준 RFC7230~RFC7235 이후로 HTTP 전송정보를 엔티티라는 말대신 표현(Representation)을 사용한다.
- 메세지 본문(body)를 통해 데이터가 전달되며 메시지 본문을 페이로드 라고 한다.
- Conten-Type: 표현 데이터의 형식 (ex text/html, appication/json, image/png ...)
- Content-Encoding: 표현 데이터의 압축 방식 - 데이터를 읽는 쪽에서 압축 해제를 하기 위함 (ex gzip..)
- Content-Language: 표현 데이터의 자연 언어 (ex en, ko..)
- Content-Length: 표현 데이터의 길이 (byte)

### [협상 - 컨텐츠 네고시에이션]
- 클라이언트가 원하는 컨텐츠 정보에 대한 요청
- 선호하는 미디어 타입, 인코딩, 압축 방식, 자연언어를 말해줄 수 있다.
- 0~1사이의 숫자를 사용하여서 원하는 방식의 우선순위(Quiality Values(q))를 줄 수 있다. (ex Accept-Language: ko-KR,ko;q=0.9,en-US;q=0.8)
- 구체적으로 명시되어 있는 것의 우선순위가 높다. (ex text/plain의 우선순위는 text/* 보다 높고, */* 인 경우 가장 낮다.)
- 구체적인 것을 기준으로 미디어 타입을 맞춘다. (강의 참고)

### [전송 방식]
- 단순 전송, 압축 전송(압축하여 전송), 분할 전송(페이로드를 나누어서 전송), 범위 전송(누나어진 데이터의 일부분의 범위를 지정하여 전송) 이 있다.

### [일반 정보]
- From: 유저 에이전트의 이메일 정보 (요청시 사용하며 잘 사용되지 않는다.)
- Referer: 이전 웹페이지의 주소 (유입경로를 파악함)
- User-Agent: 유저 에이전트 애플리케이션 정보 (요청시 사용되며, 브라우저, OS..)
- Server: 요청을 처리한 오리진 서버의 정보 (중간의 프록시 정보가 아닌 진짜 요청한 서버, 응답에서 사용된다.)
- Date : 메시지가 생성된 날짜

### [특별한 정보]
- Host: 요청한 호스트 정보(도메인) 필수값이다. (하나의 서버가 여러 도메인을 처리해야 할때)
- Location: 페이지 리다이렉션 - 웹브라우저가 3xx상태코드의 Location으로 자동 이동 시킨다.
- Allow: 허용가능한 Http 메서드
- Retry-After: 유저 에이전트가 다음 요청하기까지 기다려아 하는 시간(초)

### [인증]
- Authorization: 클라이언트의 인증정보
- WWW-Authentiacte: 리소스 접근시 필요한 인증 방법 정의 (ex Newauth realm="apps", type=1,title="Login to \"apps\"", Basic realm="simple")

### [쿠키]
- Set-Cookie: 서버에서 클라이언트로 쿠키 전달 (응답)
	- expires, max-age 를 사용하여 쿠키의 유효한 기간을 지정할 수 있다.
	- 세선쿠키인 경우 브라우저 종료시에 사라진다.
	- 도메인과 경로를 사용하여 접근 가능한 주소를 지정할 수 있다.
	- 보안과 관련한 옵션: Secure(Https시에만 전송), HttpOnly(XSS 공격방지, JS에서 접근 불가), SameSite (XSRF 공격방지)
- Cookie: 클라이언트가 서버에게 받은 쿠키를 전달한다. (요청시)


## 섹션 8. HTTP 헤더2 - 캐시와 조건부 요청 (21.1.17)
### [캐시 기본 동작]
- 캐시가 없다면 사이즈가 큰 같은 요청에 대해서 매번 자원을 많이 사용해야 한다.
- 캐시처리가 필요한 경우 응답시에 `cache-control`로 캐시가 유효한 시간을 명시한다. cache-control: max-age=60 (캐시가 유효한 시간은 60초)
- 브라우저에는 캐시를 저장하는 저장소가 있고, 캐시가 유효하다면 캐시를 사용한다.
- 네트워크를 사용하지 않고 브라우저의 로딩 속도가 빨라져 빠른 사용자 경험을 제공할 수 있다.

### [검증 헤더와 조건부 요청1]
- 만약 캐시 유효시간이 만료된 경우 자원이 변경되지 않았음에도 같은 응답을 내려야 하는 문제가 있다.
- 캐시 만료후에도 서버에서 데이터를 변경하지 않은 경우 캐시를 사용하기 위해서 최종 수정일자를 사용한다.
	1. 응답시에 `Last-modified` 헤더에 해당 자원의 마지막 수정일자를 담아준다.
	2. 캐시 유효시간이 만료되었을때 요청 헤더에 `if-modified-since`로 마지막 수정일자를 담아 네트워크 요청을 보낸다.
	3. 서버에서 요청의 수정일과 서버의 수정일을 확인하여서 날짜가 같다면 status 304를 보내고 body를 담아 보내지 않는다.
	- 헤더정보만 받아서 효율적으로 네트워크 사용이 가능해진다.

### [검증헤더와 조건부 요청2]
-  Last-Modified, If-Modified-Since를 사용한 조건부 요청의 단점
	- 1초미만의 캐시 조정이 불가능
	- 자원은 변경되지 않았는데 수정 날짜가 갱신된 경우 (ex A->B->A)
	- 서버에서 별도의 캐시 로직을 관리하고 싶은 경우 (자원은 변경되었지만 같은 자원을 써도 무관하다고 느낄때)
- ETag(Entity Tag), If-None-Match
	1. 날짜가 아닌 임의의 버전을 사용한다.
	2. 캐시 유효시간이 만료된 경우 ETag의 버전을 서버에게 보낸다.
	3. 서버에서 버전이 다른 경우 304에 body를 보내지 않는다.
- ETag를 사용한 경우 서버에서 캐시 관리가 가능하다.

### [캐시와 조건부 요청 헤더]
- Cache-Control의 하위 버전 (Pragma, Expires)
	- Cache-Control: max-age (초단위로 유효시간 지정)
	- Cache-Control: no-cache인 경우 데이터를 매번 origin 서버에 검증한다. (프록시한테 검증하지 않는다)
		- origin 서버가 연결이 안될 경우 프록시 서버가 자체적으로 캐시를 사용하라고 응답 할 수 도 있다.
	- Cache-Control: no-stroe인 경우 민감한 정보가 있으므로 저장하면 안된다. (메모리에서만 삭제)

### [프록시 캐시]
- 미국에 원서버가 있는 경우 한국에 캐시용 서버를 두어서 한국 사용자들에게 응답속도를 개선했다면 한국 캐시용 서버가 프록시 캐시 서버다.
- Cache-Control: public, Cache-Control: private (강의참고)

### [캐시 무효화]
- 자체적으로 캐시를 사용하는 브라우저에게 절대 캐시를 사용하지 말라는 무효화 응답 
	- `Cache-Control: no-cache, no-store, must-revalidate`
	- `Pragma: no-cache`

